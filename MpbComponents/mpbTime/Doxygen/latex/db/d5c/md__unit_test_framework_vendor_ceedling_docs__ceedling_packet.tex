\mbox{[}All code is copyright © 2010-\/2012 Ceedling Project by Mike Karlesky, Mark Vander\+Voord, and Greg Williams.

This Documentation Is Released Under a Creative Commons 3.\+0 Attribution Share-\/\+Alike License\mbox{]}

What the What?

Assembling build environments for C projects -\/ especially with automated unit tests -\/ is a pain. Whether it\textquotesingle{}s Make or Rake or Premake or what-\/have-\/you, set up with an all-\/purpose build environment tool is tedious and requires considerable glue code to pull together the necessary tools and libraries. Ceedling allows you to generate an entire test and build environment for a C project from a single YAML configuration file. Ceedling is written in Ruby and works with the Rake build tool plus other goodness like Unity and CMock
\begin{DoxyItemize}
\item the unit testing and mocking frameworks for C. Ceedling and its complementary tools can support the tiniest of embedded processors, the beefiest 64 bit power houses available, and everything in between.
\end{DoxyItemize}

For a build project including unit tests and using the default toolchain gcc, the configuration file could be as simple as this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{:project:}
\DoxyCodeLine{  :build\_root: project/build/}
\DoxyCodeLine{  :release\_build: TRUE}
\DoxyCodeLine{}
\DoxyCodeLine{:paths:}
\DoxyCodeLine{  :test:}
\DoxyCodeLine{    -\/ tests/**}
\DoxyCodeLine{  :source:}
\DoxyCodeLine{    -\/ source/**}

\end{DoxyCode}


From the command line, to build the release version of your project, you would simply run {\ttfamily ceedling release}. To run all your unit tests, you would run {\ttfamily ceedling test\+:all}. That\textquotesingle{}s it!

Of course, many more advanced options allow you to configure your project with a variety of features to meet a variety of needs. Ceedling can work with practically any command line toolchain and directory structure – all by way of the configuration file. Further, because Ceedling piggy backs on Rake, you can add your own Rake tasks to accomplish project tasks outside of testing and release builds. A facility for plugins also allows you to extend Ceedling\textquotesingle{}s capabilities for needs such as custom code metrics reporting and coverage testing.

What\textquotesingle{}s with this Name?

Glad you asked. Ceedling is tailored for unit tested C projects and is built upon / around Rake (Rake is a Make replacement implemented in the Ruby scripting language). So, we\textquotesingle{}ve got C, our Rake, and the fertile soil of a build environment in which to grow and tend your project and its unit tests. Ta da -\/ {\itshape Ceedling}.

What Do You Mean \char`\"{}tailored for unit tested C projects\char`\"{}?

Well, we like to write unit tests for our C code to make it lean and mean (that whole \href{http://en.wikipedia.org/wiki/Test-driven_development}{\texttt{ Test-\/\+Driven Development}} thing). Along the way, this style of writing C code spawned two tools to make the job easier\+: a unit test framework for C called {\itshape Unity} and a mocking library called {\itshape CMock}. And, though it\textquotesingle{}s not directly related to testing, a C framework for exception handling called {\itshape CException} also came along.

These tools and frameworks are great, but they require quite a bit of environment support to pull them all together in a convenient, usable fashion. We started off with Rakefiles to assemble everything. These ended up being quite complicated and had to be hand-\/edited or created anew for each new project. Ceedling replaces all that tedium and rework with a configuration file that ties everything together.

Though Ceedling is tailored for unit testing, it can also go right ahead and build your final binary release artifact for you as well. Or, Ceedling and your tests can live alongside your existing release build setup. That said, Ceedling is more powerful as a unit test build environment than it is a general purpose release build environment; complicated projects including separate bootloaders or multiple library builds, etc. are not its strong suit.

Hold on. Back up. Ruby? Rake? YAML? Unity? CMock? CException?

Seem overwhelming? It\textquotesingle{}s not bad at all, and for the benefits tests bring us, it\textquotesingle{}s all worth it.

\href{http://www.ruby-lang.org/en/}{\texttt{ Ruby}} is a handy scripting language like Perl or Python. It\textquotesingle{}s a modern, full featured language that happens to be quite handy for accomplishing tasks like code generation or automating one\textquotesingle{}s workflow while developing in a compiled language such as C.

\href{http://rubyrake.org/}{\texttt{ Rake}} is a utility written in Ruby for accomplishing dependency tracking and task automation common to building software. It\textquotesingle{}s a modern, more flexible replacement for \href{http://en.wikipedia.org/wiki/Make_(software)}{\texttt{ Make}}). Rakefiles are Ruby files, but they contain build targets similar in nature to that of Makefiles (but you can also run Ruby code in your Rakefile).

\href{http://en.wikipedia.org/wiki/Yaml}{\texttt{ YAML}} is a \char`\"{}human friendly data serialization standard for all programming languages.\char`\"{} It\textquotesingle{}s kinda like a markup language, but don\textquotesingle{}t call it that. With a YAML library, you can \href{http://en.wikipedia.org/wiki/Serialization}{\texttt{ serialize}} data structures to and from the file system in a textual, human readable form. Ceedling uses a serialized data structure as its configuration input.

\href{http://github.com/ThrowTheSwitch/Unity}{\texttt{ Unity}} is a \href{http://en.wikipedia.org/wiki/Unit_testing}{\texttt{ unit test framework}} for C. It provides facilities for test assertions, executing tests, and collecting / reporting test results. Unity derives its name from its implementation in a single C source file (plus two C header files) and from the nature of its implementation -\/ Unity will build in any C toolchain and is configurable for even the very minimalist of processors.

\href{http://github.com/ThrowTheSwitch/CMock}{\texttt{ CMock}} is a tool written in Ruby able to generate entire \href{http://en.wikipedia.org/wiki/Mock_object}{\texttt{ mock functions}} in C code from a given C header file. Mock functions are invaluable in \href{http://martinfowler.com/articles/mocksArentStubs.html}{\texttt{ interaction-\/based unit testing}}. CMock\textquotesingle{}s generated C code uses Unity.

\href{http://github.com/ThrowTheSwitch/CException}{\texttt{ CException}} is a C source and header file that provide a simple \href{http://en.wikipedia.org/wiki/Exception_handling}{\texttt{ exception mechanism}} for C by way of wrapping up the \href{http://en.wikipedia.org/wiki/Setjmp.h}{\texttt{ setjmp / longjmp}} standard library calls. Exceptions are a much cleaner and preferable alternative to managing and passing error codes up your return call trace.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md0}{}\doxysubsection{Notes}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md0}

\begin{DoxyItemize}
\item YAML support is included with Ruby -\/ requires no special installation or configuration.
\item Unity, CMock, and CException are bundled with Ceedling, and Ceedling is designed to glue them all together for your project as seamlessly as possible.
\end{DoxyItemize}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md1}{}\doxysubsection{Installation \& Setup\+: What Exactly Do I Need to Get Started?}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md1}
As a \href{http://docs.rubygems.org/read/chapter/1}{\texttt{ Ruby gem}}\+:


\begin{DoxyEnumerate}
\item \href{http://www.ruby-lang.org/en/downloads/}{\texttt{ Download and install Ruby}}
\item Use Ruby\textquotesingle{}s command line gem package manager to install Ceedling\+: {\ttfamily gem install ceedling} (Unity, CMock, and CException come along with Ceedling for free)
\item Execute Ceedling at command line to create example project or an empty Ceedling project in your filesystem (executing {\ttfamily ceedling help} first is, well, helpful).
\end{DoxyEnumerate}

Gem install notes\+:


\begin{DoxyEnumerate}
\item Steps 1-\/2 are a one time affair for your local environment. When steps 1-\/2 are completed once, only step 3 is needed for each new project.
\end{DoxyEnumerate}

General notes\+:


\begin{DoxyEnumerate}
\item Certain advanced features of Ceedling rely on gcc and cpp as preprocessing tools. In most $\ast$nix systems, these tools are already available. For Windows environments, we recommend the \href{http://www.mingw.org/}{\texttt{ mingw project}} (Minimalist GNU for Windows). This represents an optional, additional setup / installation step to complement the list above. Upon installing mingw ensure your system path is updated or set \mbox{[}\+:environment\mbox{]}\mbox{[}\+:path\mbox{]} in your {\ttfamily project.\+yml} file (see environment section later in this document).
\item To use a project file name other than the default {\ttfamily project.\+yml} or place the project file in a directory other than the one in which you\textquotesingle{}ll run Rake, create an environment variable {\ttfamily CEEDLING\+\_\+\+MAIN\+\_\+\+PROJECT\+\_\+\+FILE} with your desired project file path.
\item To better understand Rake conventions, Rake execution, and Rakefiles, consult the \href{http://rubyrake.org/}{\texttt{ Rake tutorial, examples, and user guide}}.
\item When using Ceedling in Windows environments, a test file name may not include the sequences “patch” or “setup”. The Windows Installer Detection Technology (part of UAC), requires administrator privileges to execute file names with these strings.
\end{DoxyEnumerate}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md2}{}\doxysubsection{Now What? How Do I Make It GO?}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md2}
We\textquotesingle{}re getting a little ahead of ourselves here, but it\textquotesingle{}s good context on how to drive this bus. Everything is done via the command line. We\textquotesingle{}ll cover conventions and how to actually configure your project in later sections.

To run tests, build your release artifact, etc., you will be interacting with Rake on the command line. Ceedling works with Rake to present you with named tasks that coordinate the file generation and build steps needed to accomplish something useful. You can also add your own independent Rake tasks or create plugins to extend Ceedling (more on this later).


\begin{DoxyItemize}
\item {\ttfamily ceedling \mbox{[}no arguments\mbox{]}}\+:

Run the default Rake task (conveniently recognized by the name default by Rake). Neither Rake nor Ceedling provide a default task. Rake will abort if run without arguments when no default task is defined. You can conveniently define a default task in the Rakefile discussed in the preceding setup \& installation section of this document.
\item {\ttfamily ceedling -\/T}\+:

List all available Rake tasks with descriptions (Rake tasks without descriptions are not listed). -\/T is a command line switch for Rake and not the same as tasks that follow.
\item {\ttfamily ceedling $<$tasks...$>$ -\/-\/trace}\+:

For advanced users troubleshooting a confusing build error, debug Ceedling or a plugin, --trace provides a stack trace of dependencies walked during task execution and any Ruby failures along the way. Note that --trace is a command line switch for Rake and is not the same as tasks that follow.
\item {\ttfamily ceedling environment}\+:

List all configured environment variable names and string values. This task is helpful in verifying the evaluatio of any Ruby expressions in the \mbox{[}\+:environment\mbox{]} section of your config file.\`{}\+: Note\+: Ceedling may set some convenience environment variables by default.
\item {\ttfamily ceedling paths\+:$\ast$}\+:

List all paths collected from \mbox{[}\+:paths\mbox{]} entries in your YAML config file where $\ast$ is the name of any section contained in \mbox{[}\+:paths\mbox{]}. This task is helpful in verifying the expansion of path wildcards / globs specified in the \mbox{[}\+:paths\mbox{]} section of your config file.
\item {\ttfamily ceedling files\+:assembly}
\item {\ttfamily ceedling files\+:header}
\item {\ttfamily ceedling files\+:source}
\item {\ttfamily ceedling files\+:test}

List all files and file counts collected from the relevant search paths specified by the \mbox{[}\+:paths\mbox{]} entries of your YAML config file. The files\+:assembly task will only be available if assembly support is enabled in the \mbox{[}\+:release\+\_\+build\mbox{]} section of your configuration file.
\item {\ttfamily ceedling options\+:$\ast$}\+:

Load and merge configuration settings into the main project configuration. Each task is named after a $\ast$.yml file found in the configured options directory. See documentation for the configuration setting \mbox{[}\+:project\mbox{]}\mbox{[}\+:options\+\_\+path\mbox{]} and for options files in advanced topics.
\item {\ttfamily ceedling test\+:all}\+:

Run all unit tests (rebuilding anything that\textquotesingle{}s changed along the way).
\item {\ttfamily ceedling test\+:delta}\+:

Run only those unit tests for which the source or test files have changed (i.\+e. incremental build). Note\+: with the \mbox{[}\+:project\mbox{]}\mbox{[}\+:use\+\_\+test\+\_\+preprocessor\mbox{]} configuration file option set, runner files are always regenerated limiting the total efficiency this text execution option can afford.
\item {\ttfamily ceedling test\+:$\ast$}\+:

Execute the named test file or the named source file that has an accompanying test. No path. Examples\+: ceedling test\+:\mbox{\hyperlink{foo_8c}{foo.\+c}} or ceed test\+:\mbox{\hyperlink{test__foo_8c}{test\+\_\+foo.\+c}}
\item {\ttfamily ceedling test\+:pattern\mbox{[}$\ast$\mbox{]}}\+:

Execute any tests whose name and/or path match the regular expression pattern (case sensitive). Example\+: ceedling \char`\"{}test\+:pattern\mbox{[}(\+I$\vert$i)nit\mbox{]}\char`\"{} will execute all tests named for initialization testing. Note\+: quotes may be necessary around the ceedling parameter to distinguish regex characters from command line operators.
\item {\ttfamily ceedling test\+:path\mbox{[}$\ast$\mbox{]}}\+:

Execute any tests whose path contains the given string (case sensitive). Example\+: ceedling test\+:path\mbox{[}foo/bar\mbox{]} will execute all tests whose path contains foo/bar. Note\+: both directory separator characters / and \textbackslash{} are valid.
\item {\ttfamily ceedling release}\+:

Build all source into a release artifact (if the release build option is configured).
\item {\ttfamily ceedling release\+:compile\+:$\ast$}\+:

Sometimes you just need to compile a single file dagnabit. Example\+: ceedling release\+:compile\+:\mbox{\hyperlink{foo_8c}{foo.\+c}}
\item {\ttfamily ceedling release\+:assemble\+:$\ast$}\+:

Sometimes you just need to assemble a single file doggonit. Example\+: ceedling release\+:assemble\+:foo.\+s
\item {\ttfamily ceedling module\+:create\mbox{[}Filename\mbox{]}}\+:
\item {\ttfamily ceedling module\+:create\mbox{[}$<$Path\+:$>$Filename\mbox{]}}\+:

It\textquotesingle{}s often helpful to create a file automatically. What\textquotesingle{}s better than that? Creating a source file, a header file, and a corresponding test file all in one step!

There are also patterns which can be specified to automatically generate a bunch of files. Try {\ttfamily ceedling module\+:create\mbox{[}Poodles,mch\mbox{]}} for example!

The module generator has several options you can configure. F.\+e. Generating the source/header/test file in a subdirectory (by adding $<$\+Path$>$ when calling module\+:create). For more info, refer to the \href{https://github.com/ThrowTheSwitch/Ceedling/blob/master/docs/CeedlingPacket.md\#module-generator}{\texttt{ Module Generator}} section.
\item {\ttfamily ceedling logging $<$tasks...$>$}\+:

Enable logging to $<$build path$>$/logs. Must come before test and release tasks to log their steps and output. Log names are a concatenation of project, user, and option files loaded. User and option files are documented in the advanced topics section of this document.
\item {\ttfamily ceedling verbosity\mbox{[}x\mbox{]} $<$tasks...$>$}\+:

Change the default verbosity level. \mbox{[}x\mbox{]} ranges from 0 (quiet) to 4 (obnoxious). Level \mbox{[}3\mbox{]} is the default. The verbosity task must precede all tasks in the command line list for which output is desired to be seen. Verbosity settings are generally most meaningful in conjunction with test and release tasks.
\item {\ttfamily ceedling summary}\+:

If plugins are enabled, this task will execute the summary method of any plugins supporting it. This task is intended to provide a quick roundup of build artifact metrics without re-\/running any part of the build.
\item {\ttfamily ceedling clean}\+:

Deletes all toolchain binary artifacts (object files, executables), test results, and any temporary files. Clean produces no output at the command line unless verbosity has been set to an appreciable level.
\item {\ttfamily ceedling clobber}\+:

Extends clean task\textquotesingle{}s behavior to also remove generated files\+: test runners, mocks, preprocessor output. Clobber produces no output at the command line unless verbosity has been set to an appreciable level.
\end{DoxyItemize}

To better understand Rake conventions, Rake execution, and Rakefiles, consult the \href{http://rubyrake.org/}{\texttt{ Rake tutorial, examples, and user guide}}.

At present, none of Ceedling\textquotesingle{}s commands provide persistence. That is, they must each be specified at the command line each time they are needed. For instance, Ceedling\textquotesingle{}s verbosity command only affects output at the time it\textquotesingle{}s run.

Individual test and release file tasks are not listed in {\ttfamily -\/T} output. Because so many files may be present it\textquotesingle{}s unwieldy to list them all.

Multiple rake tasks can be executed at the command line (order is executed as provided). For example, {\ttfamily ceed clobber test\+:all release} will removed all generated files; build and run all tests; and then build all source -\/ in that order. If any Rake task fails along the way, execution halts before the next task.

The {\ttfamily clobber} task removes certain build directories in the course of deleting generated files. In general, it\textquotesingle{}s best not to add to source control any Ceedling generated directories below the root of your top-\/level build directory. That is, leave anything Ceedling \& its accompanying tools generate out of source control (but go ahead and add the top-\/level build directory that holds all that stuff). Also, since Ceedling is pretty smart about what it rebuilds and regenerates, you needn\textquotesingle{}t clobber often.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md3}{}\doxysection{Important Conventions}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md3}
\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md4}{}\doxysubsection{Directory Structure, Filenames \& Extensions}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md4}
Much of Ceedling\textquotesingle{}s functionality is driven by collecting files matching certain patterns inside the paths it\textquotesingle{}s configured to search. See the documentation for the \mbox{[}\+:extensions\mbox{]} section of your configuration file (found later in this document) to configure the file extensions Ceedling uses to match and collect files. Test file naming is covered later in this section.

Test files and source files must be segregated by directories. Any directory structure will do. Tests can be held in subdirectories within source directories, or tests and source directories can be wholly separated at the top of your project\textquotesingle{}s directory tree.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md5}{}\doxysubsection{Search Path Order}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md5}
When Ceedling searches for files (e.\+g. looking for header files to mock) or when it provides search paths to any of the default gcc toolchain executables, it organizes / prioritizes its search paths. The order is always\+: test paths, support paths, source paths, and then include paths. This can be useful, for instance, in certain testing scenarios where we desire Ceedling or a compiler to find a stand-\/in header file in our support directory before the actual source header file of the same name.

This convention only holds when Ceedling is using its default tool configurations and / or when tests are involved. If you define your own tools in the configuration file (see the \mbox{[}\+:tools\mbox{]} section documented later in this here document), you have complete control over what directories are searched and in what order. Further, test and support directories are only searched when appropriate. That is, when running a release build, test and support directories are not used at all.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md6}{}\doxysubsection{Source Files \& Binary Release Artifacts}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md6}
Your binary release artifact results from the compilation and linking of all source files Ceedling finds in the specified source directories. At present only source files with a single (configurable) extension are recognized. That is, $\ast$.c and $\ast$.cc files will not both be recognized -\/ only one or the other. See the configuration options and defaults in the documentation for the \mbox{[}\+:extensions\mbox{]} sections of your configuration file (found later in this document).\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md7}{}\doxysubsection{Test Files \& Executable Test Fixtures}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md7}
Ceedling builds each individual test file with its accompanying source file(s) into a single, monolithic test fixture executable. Test files are recognized by a naming convention\+: a (configurable) prefix such as \char`\"{}\`{}test\+\_\+\`{}\char`\"{} in the file name with the same file extension as used by your C source files. See the configuration options and defaults in the documentation for the \mbox{[}\+:project\mbox{]} and \mbox{[}\+:extensions\mbox{]} sections of your configuration file (found later in this document). Depending on your configuration options, Ceedling can recognize a variety of test file naming patterns in your test search paths. For example\+: {\ttfamily test\+\_\+some\+\_\+super\+\_\+functionality.\+c}, {\ttfamily Test\+Your\+Source\+File.\+cc}, or {\ttfamily testing\+\_\+\+My\+Awesome\+Code.\+C} could each be valid test file names. Note, however, that Ceedling can recognize only one test file naming convention per project.

Ceedling knows what files to compile and link into each individual test executable by way of the \#include list contained in each test file. Any C source files in the configured search directories that correspond to the header files included in a test file will be compiled and linked into the resulting test fixture executable. From this same \#include list, Ceedling knows which files to mock and compile and link into the test executable (if you use mocks in your tests). That was a lot of clauses and information in a very few sentences; the example that follows in a bit will make it clearer.

By naming your test functions according to convention, Ceedling will extract and collect into a runner C file calls to all your test case functions. This runner file handles all the execution minutiae so that your test file can be quite simple and so that you never forget to wire up a test function to be executed. In this generated runner lives the {\ttfamily \mbox{\hyperlink{test__mpb_time_base__runner_8c_a840291bc02cba5474a4cb46a9b9566fe}{main()}}} entry point for the resulting test executable. There are no configuration options for the naming convention of your test case functions. A test case function signature must have these three elements\+: void return, void parameter list, and the function name prepended with lowercase \char`\"{}\`{}test\`{}\char`\"{}. In other words, a test function signature should look like this\+: {\ttfamily void test}{\ttfamily \mbox{[}any name you like\mbox{]}}{\ttfamily (void)}.

A commented sample test file follows on the next page. Also, see the sample project contained in the Ceedling documentation bundle.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// test\_foo.c -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{unity_8h}{unity.h}}"{}}     \textcolor{comment}{// compile/link in Unity test framework}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}types.h"{}}     \textcolor{comment}{// header file with no *.c file -\/-\/ no compilation/linking}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{foo_8h}{foo.h}}"{}}       \textcolor{comment}{// source file foo.c under test}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}mock\_bar.h"{}}  \textcolor{comment}{// bar.h will be found and mocked as mock\_bar.c + compiled/linked in;}}
\DoxyCodeLine{                       \textcolor{comment}{// foo.c includes bar.h and uses functions declared in it}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}mock\_baz.h"{}}  \textcolor{comment}{// baz.h will be found and mocked as mock\_baz.c + compiled/linked in}}
\DoxyCodeLine{                       \textcolor{comment}{// foo.c includes baz.h and uses functions declared in it}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{test__mpb_time_base_8c_a63326a1b70b6e3f070e51687798e02de}{setUp}}(\textcolor{keywordtype}{void}) \{\}    \textcolor{comment}{// every test file requires this function;}}
\DoxyCodeLine{                       \textcolor{comment}{// setUp() is called by the generated runner before each test case function}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{test__mpb_time_base_8c_ab804e0f66def63262c1d6b4e3d2a2bd7}{tearDown}}(\textcolor{keywordtype}{void}) \{\} \textcolor{comment}{// every test file requires this function;}}
\DoxyCodeLine{                       \textcolor{comment}{// tearDown() is called by the generated runner before each test case function}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// a test case function}}
\DoxyCodeLine{\textcolor{keywordtype}{void} test\_Foo\_Function1\_should\_Call\_Bar\_AndGrill(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    Bar\_AndGrill\_Expect();                    \textcolor{comment}{// setup function from mock\_bar.c that instructs our}}
\DoxyCodeLine{                                              \textcolor{comment}{// framework to expect Bar\_AndGrill() to be called once}}
\DoxyCodeLine{    \mbox{\hyperlink{unity_8h_af9e5695d6c7cf634206ea6d062cb54c9}{TEST\_ASSERT\_EQUAL}}(0xFF, Foo\_Function1()); \textcolor{comment}{// assertion provided by Unity}}
\DoxyCodeLine{                                              \textcolor{comment}{// Foo\_Function1() calls Bar\_AndGrill() \& returns a byte}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// another test case function}}
\DoxyCodeLine{\textcolor{keywordtype}{void} test\_Foo\_Function2\_should\_Call\_Baz\_Tec(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    Baz\_Tec\_ExpectAnd\_Return(1);       \textcolor{comment}{// setup function provided by mock\_baz.c that instructs our}}
\DoxyCodeLine{                                       \textcolor{comment}{// framework to expect Baz\_Tec() to be called once and return 1}}
\DoxyCodeLine{    \mbox{\hyperlink{unity_8h_a6a0527f090dfc0b5ce9724415e51ebe5}{TEST\_ASSERT\_TRUE}}(Foo\_Function2()); \textcolor{comment}{// assertion provided by Unity}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// end of test\_foo.c -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}

\end{DoxyCode}


From the test file specified above Ceedling will generate {\ttfamily test\+\_\+foo\+\_\+runner.\+c}; this runner file will contain {\ttfamily \mbox{\hyperlink{test__mpb_time_base__runner_8c_a840291bc02cba5474a4cb46a9b9566fe}{main()}}} and call both of the example test case functions.

The final test executable will be {\ttfamily test\+\_\+foo.\+exe} (for Windows machines or {\ttfamily test\+\_\+foo.\+out} for $\ast$nix systems -\/ depending on default or configured file extensions). Based on the \#include list above, the test executable will be the output of the linker having processed {\ttfamily unity.\+o}, {\ttfamily foo.\+o}, {\ttfamily mock\+\_\+bar.\+o}, {\ttfamily mock\+\_\+baz.\+o}, {\ttfamily test\+\_\+foo.\+o}, and {\ttfamily test\+\_\+foo\+\_\+runner.\+o}. Ceedling finds the files, generates mocks, generates a runner, compiles all the files, and links everything into the test executable. Ceedling will then run the test executable and collect test results from it to be reported to the developer at the command line.

For more on the assertions and mocks shown, consult the documentation for Unity and CMock.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md8}{}\doxysubsection{The Magic of Dependency Tracking}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md8}
Ceedling is pretty smart in using Rake to build up your project\textquotesingle{}s dependencies. This means that Ceedling automagically rebuilds all the appropriate files in your project when necessary\+: when your configuration changes, Ceedling or any of the other tools are updated, or your source or test files change. For instance, if you modify a header file that is mocked, Ceedling will ensure that the mock is regenerated and all tests that use that mock are rebuilt and re-\/run when you initiate a relevant testing task. When you see things rebuilding, it\textquotesingle{}s for a good reason. Ceedling attempts to regenerate and rebuild only what\textquotesingle{}s needed for a given execution of a task. In the case of large projects, assembling dependencies and acting upon them can cause some delay in executing tasks.

With one exception, the trigger to rebuild or regenerate a file is always a disparity in timestamps between a target file and its source -\/ if an input file is newer than its target dependency, the target is rebuilt or regenerated. For example, if the C source file from which an object file is compiled is newer than that object file on disk, recompilation will occur (of course, if no object file exists on disk, compilation will always occur). The one exception to this dependency behavior is specific to your input configuration. Only if your logical configuration changes will a system-\/wide rebuild occur. Reorganizing your input configuration or otherwise updating its file timestamp without modifying the values within the file will not trigger a rebuild. This behavior handles the various ways in which your input configuration can change (discussed later in this document) without having changed your actual project YAML file.

Ceedling needs a bit of help to accomplish its magic with deep dependencies. Shallow dependencies are straightforward\+: a mock is dependent on the header file from which it\textquotesingle{}s generated, a test file is dependent upon the source files it includes (see the preceding conventions section), etc. Ceedling handles these \char`\"{}out of the box.\char`\"{} Deep dependencies are specifically a C-\/related phenomenon and occur as a consequence of include statements within C source files. Say a source file includes a header file and that header file in turn includes another header file which includes still another header file. A change to the deepest header file should trigger a recompilation of the source file, a relinking of all the object files comprising a test fixture, and a new execution of that test fixture.

Ceedling can handle deep dependencies but only with the help of a C preprocessor. Ceedling is quite capable, but a full C preprocessor it ain\textquotesingle{}t. Your project can be configured to use a C preprocessor or not. Simple projects or large projects constructed so as to be quite flat in their include structure generally don\textquotesingle{}t need deep dependency preprocessing -\/ and can enjoy the benefits of faster execution. Legacy code, on the other hand, will almost always want to be tested with deep preprocessing enabled. Set up of the C preprocessor is covered in the documentation for the \mbox{[}\+:project\mbox{]} and \mbox{[}\+:tools\mbox{]} section of the configuration file (later in this document). Ceedling contains all the configuration necessary to use the gcc preprocessor by default. That is, as long as gcc is in your system search path, deep preprocessing of deep dependencies is available to you by simply enabling it in your project configuration file.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md9}{}\doxysubsection{Ceedling\textquotesingle{}s Build Output}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md9}
Ceedling requires a top-\/level build directory for all the stuff that it, the accompanying test tools, and your toolchain generate. That build directory\textquotesingle{}s location is configured in the \mbox{[}\+:project\mbox{]} section of your configuration file (discussed later). There can be a ton of generated files. By and large, you can live a full and meaningful life knowing absolutely nothing at all about the files and directories generated below the root build directory.

As noted already, it\textquotesingle{}s good practice to add your top-\/level build directory to source control but nothing generated beneath it. You\textquotesingle{}ll spare yourself headache if you let Ceedling delete and regenerate files and directories in a non-\/versioned corner of your project\textquotesingle{}s filesystem beneath the top-\/level build directory.

The {\ttfamily artifacts} directory is the one and only directory you may want to know about beneath the top-\/level build directory. The subdirectories beneath {\ttfamily artifacts} will hold your binary release target output (if your project is configured for release builds) and will serve as the conventional location for plugin output. This directory structure was chosen specifically because it tends to work nicely with Continuous Integration setups that recognize and list build artifacts for retrieval / download.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md10}{}\doxysubsection{The Almighty Project Configuration File (in Glorious YAML)}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md10}
Please consult YAML documentation for the finer points of format and to understand details of our YAML-\/based configuration file. We recommend \href{http://en.wikipedia.org/wiki/Yaml}{\texttt{ Wikipedia\textquotesingle{}s entry on YAML}} for this. A few highlights from that reference page\+:


\begin{DoxyItemize}
\item YAML streams are encoded using the set of printable Unicode characters, either in UTF-\/8 or UTF-\/16
\item Whitespace indentation is used to denote structure; however tab characters are never allowed as indentation
\item Comments begin with the number sign ( \# ), can start anywhere on a line, and continue until the end of the line unless enclosed by quotes
\item List members are denoted by a leading hyphen ( -\/ ) with one member per line, or enclosed in square brackets ( \mbox{[} \mbox{]} ) and separated by comma space ( , )
\item Hashes are represented using the colon space ( \+: ) in the form key\+: value, either one per line or enclosed in curly braces ( \{ \} ) and separated by comma space ( , )
\item Strings (scalars) are ordinarily unquoted, but may be enclosed in double-\/quotes ( "{} ), or single-\/quotes ( \textquotesingle{} )
\item YAML requires that colons and commas used as list separators be followed by a space so that scalar values containing embedded punctuation can generally be represented without needing to be enclosed in quotes
\item Repeated nodes are initially denoted by an ampersand ( \& ) and thereafter referenced with an asterisk ( $\ast$ )
\end{DoxyItemize}

Notes on what follows\+:


\begin{DoxyItemize}
\item Each of the following sections represent top-\/level entries in the YAML configuration file.
\item Unless explicitly specified in the configuration file, default values are used by Ceedling.
\item These three settings, at minimum, must be specified\+:
\begin{DoxyItemize}
\item \mbox{[}\+:project\mbox{]}\mbox{[}\+:build\+\_\+root\mbox{]}
\item \mbox{[}\+:paths\mbox{]}\mbox{[}\+:source\mbox{]}
\item \mbox{[}\+:paths\mbox{]}\mbox{[}\+:test\mbox{]}
\end{DoxyItemize}
\item As much as is possible, Ceedling validates your settings in properly formed YAML.
\item Improperly formed YAML will cause a Ruby error when the YAML is parsed. This is usually accompanied by a complaint with line and column number pointing into the project file.
\item Certain advanced features rely on gcc and cpp as preprocessing tools. In most $\ast$nix systems, these tools are already available. For Windows environments, we recommend the \href{http://www.mingw.org/}{\texttt{ mingw project}} (Minimalist GNU for Windows).
\item Ceedling is primarily meant as a build tool to support automated unit testing. All the heavy lifting is involved there. Creating a simple binary release build artifact is quite trivial in comparison. Consequently, most default options and the construction of Ceedling itself is skewed towards supporting testing though Ceedling can, of course, build your binary release artifact as well. Note that complex binary release artifacts (e.\+g. application + bootloader or multiple libraries) are beyond Ceedling\textquotesingle{}s release build ability.
\end{DoxyItemize}

Conventions / features of Ceedling-\/specific YAML\+:


\begin{DoxyItemize}
\item Any second tier setting keys anywhere in YAML whose names end in {\ttfamily \+\_\+path} or {\ttfamily \+\_\+paths} are automagically processed like all Ceedling-\/specific paths in the YAML to have consistent directory separators (i.\+e. \char`\"{}/\char`\"{}) and to take advantage of inline Ruby string expansion (see \mbox{[}\+:environment\mbox{]} setting below for further explanation of string expansion).
\end{DoxyItemize}

{\bfseries{Let\textquotesingle{}s Be Careful Out There\+:}} Ceedling performs validation on the values you set in your configuration file (this assumes your YAML is correct and will not fail format parsing, of course). That said, validation is limited to only those settings Ceedling uses and those that can be reasonably validated. Ceedling does not limit what can exist within your configuration file. In this way, you can take full advantage of YAML as well as add sections and values for use in your own custom plugins (documented later). The consequence of this is simple but important. A misspelled configuration section name or value name is unlikely to cause Ceedling any trouble. Ceedling will happily process that section or value and simply use the properly spelled default maintained internally -\/ thus leading to unexpected behavior without warning.

project\+: global project settings


\begin{DoxyItemize}
\item {\ttfamily build\+\_\+root}\+:

Top level directory into which generated path structure and files are placed. Note\+: this is one of the handful of configuration values that must be set. The specified path can be absolute or relative to your working directory.

{\bfseries{Default}}\+: (none)
\item {\ttfamily use\+\_\+exceptions}\+:

Configures the build environment to make use of CException. Note that if you do not use exceptions, there\textquotesingle{}s no harm in leaving this as its default value.

{\bfseries{Default}}\+: TRUE
\item {\ttfamily use\+\_\+mocks}\+:

Configures the build environment to make use of CMock. Note that if you do not use mocks, there\textquotesingle{}s no harm in leaving this setting as its default value.

{\bfseries{Default}}\+: TRUE
\item {\ttfamily use\+\_\+test\+\_\+preprocessor}\+:

This option allows Ceedling to work with test files that contain conditional compilation statements (e.\+g. \#ifdef) and header files you wish to mock that contain conditional preprocessor statements and/or macros.

Ceedling and CMock are advanced tools with sophisticated parsers. However, they do not include entire C language preprocessors. Consequently, with this option enabled, Ceedling will use gcc\textquotesingle{}s preprocessing mode and the cpp preprocessor tool to strip down / expand test files and headers to their applicable content which can then be processed by Ceedling and CMock.

With this option enabled, the gcc \& cpp tools must exist in an accessible system search path and test runner files are always regenerated.

{\bfseries{Default}}\+: FALSE
\item {\ttfamily use\+\_\+deep\+\_\+dependencies}\+:

The base rules and tasks that Ceedling creates using Rake capture most of the dependencies within a standard project (e.\+g. when the source file accompanying a test file changes, the corresponding test fixture executable will be rebuilt when tests are re-\/run). However, deep dependencies cannot be captured this way. If a typedef or macro changes in a header file three levels of \#include statements deep, this option allows the appropriate incremental build actions to occur for both test execution and release builds.

This is accomplished by using the dependencies discovery mode of gcc. With this option enabled, gcc must exist in an accessible system search path.

{\bfseries{Default}}\+: FALSE
\item {\ttfamily generate\+\_\+deep\+\_\+dependencies}\+:

When {\ttfamily use\+\_\+deep\+\_\+dependencies} is set to TRUE, Ceedling will run a separate build step to generate the deep dependencies. If you are using gcc as your primary compiler, or another compiler that can generate makefile rules as a side effect of compilation, then you can set this to FALSE to avoid the extra build step but still use the deep dependencies data when deciding which source files to rebuild.

{\bfseries{Default}}\+: TRUE
\item {\ttfamily test\+\_\+file\+\_\+prefix}\+:

Ceedling collects test files by convention from within the test file search paths. The convention includes a unique name prefix and a file extension matching that of source files.

Why not simply recognize all files in test directories as test files? By using the given convention, we have greater flexibility in what we do with C files in the test directories.

{\bfseries{Default}}\+: \char`\"{}test\+\_\+\char`\"{}
\item {\ttfamily options\+\_\+paths}\+:

Just as you may have various build configurations for your source codebase, you may need variations of your project configuration.

By specifying options paths, Ceedling will search for other project YAML files, make command line tasks available (ceedling options\+:variation for a variation.\+yml file), and merge the project configuration of these option files in with the main project file at runtime. See advanced topics.

Note these Rake tasks at the command line -\/ like verbosity or logging control -\/ must come before the test or release task they are meant to modify.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily release\+\_\+build}\+:

When enabled, a release Rake task is exposed. This configuration option requires a corresponding release compiler and linker to be defined (gcc is used as the default).

More release configuration options are available in the release\+\_\+build section.

{\bfseries{Default}}\+: FALSE
\end{DoxyItemize}

Example {\ttfamily \mbox{[}\+:project\mbox{]}} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:project:}
\DoxyCodeLine{  :build\_root: project\_awesome/build}
\DoxyCodeLine{  :use\_exceptions: FALSE}
\DoxyCodeLine{  :use\_test\_preprocessor: TRUE}
\DoxyCodeLine{  :use\_deep\_dependencies: TRUE}
\DoxyCodeLine{  :options\_paths:}
\DoxyCodeLine{    -\/ project/options}
\DoxyCodeLine{    -\/ external/shared/options}
\DoxyCodeLine{  :release\_build: TRUE}

\end{DoxyCode}


Ceedling is primarily concerned with facilitating the somewhat complicated mechanics of automating unit tests. The same mechanisms are easily capable of building a final release binary artifact (i.\+e. non test code; the thing that is your final working software that you execute on target hardware).


\begin{DoxyItemize}
\item {\ttfamily output}\+:

The name of your release build binary artifact to be found in $<$build   path$>$/artifacts/release. Ceedling sets the default artifact file extension to that as is explicitly specified in the \mbox{[}\+:extensions\mbox{]} section or as is system specific otherwise.

{\bfseries{Default}}\+: {\ttfamily project.\+exe} or {\ttfamily project.\+out}
\item {\ttfamily use\+\_\+assembly}\+:

If assembly code is present in the source tree, this option causes Ceedling to create appropriate build directories and use an assembler tool (default is the GNU tool as -\/ override available in the \mbox{[}\+:tools\mbox{]} section.

{\bfseries{Default}}\+: FALSE
\item {\ttfamily artifacts}\+:

By default, Ceedling copies to the $<$build path$>$/artifacts/release directory the output of the release linker and (optionally) a map file. Many toolchains produce other important output files as well. Adding a file path to this list will cause Ceedling to copy that file to the artifacts directory. The artifacts directory is helpful for organizing important build output files and provides a central place for tools such as Continuous Integration servers to point to build output. Selectively copying files prevents incidental build cruft from needlessly appearing in the artifacts directory. Note that inline Ruby string replacement is available in the artifacts paths (see discussion in the \mbox{[}\+:environment\mbox{]} section).

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

Example {\ttfamily \mbox{[}\+:release\+\_\+build\mbox{]}} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:release\_build:}
\DoxyCodeLine{  :output: top\_secret.bin}
\DoxyCodeLine{  :use\_assembly: TRUE}
\DoxyCodeLine{  :artifacts:}
\DoxyCodeLine{    -\/ build/release/out/c/top\_secret.s19}

\end{DoxyCode}


{\bfseries{paths}}\+: options controlling search paths for source and header (and assembly) files


\begin{DoxyItemize}
\item {\ttfamily test}\+:

All C files containing unit test code. Note\+: this is one of the handful of configuration values that must be set.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily source}\+:

All C files containing release code (code to be tested). Note\+: this is one of the handful of configuration values that must be set.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily support}\+:

Any C files you might need to aid your unit testing. For example, on occasion, you may need to create a header file containing a subset of function signatures matching those elsewhere in your code (e.\+g. a subset of your OS functions, a portion of a library API, etc.). Why? To provide finer grained control over mock function substitution or limiting the size of the generated mocks.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily include}\+:

Any header files not already in the source search path. Note there\textquotesingle{}s no practical distinction between this search path and the source search path; it\textquotesingle{}s merely to provide options or to support any peculiar source tree organization.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily test\+\_\+toolchain\+\_\+include}\+:

System header files needed by the test toolchain -\/ should your compiler be unable to find them, finds the wrong system include search path, or you need a creative solution to a tricky technical problem. Note that if you configure your own toolchain in the \mbox{[}\+:tools\mbox{]} section, this search path is largely meaningless to you. However, this is a convenient way to control the system include path should you rely on the default gcc tools.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily release\+\_\+toolchain\+\_\+include}\+:

Same as preceding albeit related to the release toolchain.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily $<$custom$>$}

Any paths you specify for custom list. List is available to tool configurations and/or plugins. Note a distinction. The preceding names are recognized internally to Ceedling and the path lists are used to build collections of files contained in those paths. A custom list is just that -\/ a custom list of paths.
\end{DoxyItemize}

Notes on path grammar within the \mbox{[}\+:paths\mbox{]} section\+:


\begin{DoxyItemize}
\item Order of search paths listed in \mbox{[}\+:paths\mbox{]} is preserved when used by an entry in the \mbox{[}\+:tools\mbox{]} section
\item Wherever multiple path lists are combined for use Ceedling prioritizes path groups as follows\+: test paths, support paths, source paths, include paths.

This can be useful, for instance, in certain testing scenarios where we desire Ceedling or the compiler to find a stand-\/in header file before the actual source header file of the same name.
\item Paths\+:
\begin{DoxyEnumerate}
\item can be absolute or relative
\item can be singly explicit -\/ a single fully specified path
\item can include a glob operator (more on this below)
\item can use inline Ruby string replacement (see \mbox{[}\+:environment\mbox{]} section for more)
\item default as an addition to a specific search list (more on this in the examples)
\item can act to subtract from a glob included in the path list (more on this in the examples)
\end{DoxyEnumerate}
\end{DoxyItemize}

\href{http://ruby.about.com/od/beginningruby/a/dir2.htm}{\texttt{ Globs}} as used by Ceedling are wildcards for specifying directories without the need to list each and every required search path. Ceedling globs operate just as Ruby globs except that they are limited to matching directories and not files. Glob operators include the following $\ast$ $\ast$$\ast$ ? \mbox{[}-\/\mbox{]} \{,\} (note\+: this list is space separated and not comma separated as commas are used within the bracket operators).


\begin{DoxyItemize}
\item {\ttfamily $\ast$}\+:

All subdirectories of depth 1 below the parent path and including the parent path
\item {\ttfamily $\ast$$\ast$}\+:

All subdirectories recursively discovered below the parent path and including the parent path
\item {\ttfamily ?}\+:

Single alphanumeric character wildcard
\item {\ttfamily \mbox{[}x-\/y\mbox{]}}\+:

Single alphanumeric character as found in the specified range
\item {\ttfamily \{x,y\}}\+:

Single alphanumeric character from the specified list
\end{DoxyItemize}

Example \mbox{[}\+:paths\mbox{]} YAML blurbs


\begin{DoxyCode}{0}
\DoxyCodeLine{:paths:}
\DoxyCodeLine{  :source:              \#together the following comprise all source search paths}
\DoxyCodeLine{    -\/ project/source/*  \#expansion yields all subdirectories of depth 1 plus parent directory}
\DoxyCodeLine{    -\/ project/lib       \#single path}
\DoxyCodeLine{  :test:                \#all test search paths}
\DoxyCodeLine{    -\/ project/**/test?  \#expansion yields any subdirectory found anywhere in the project that}
\DoxyCodeLine{                        \#begins with "{}test"{} and contains 5 characters}
\DoxyCodeLine{}
\DoxyCodeLine{:paths:}
\DoxyCodeLine{  :source:                           \#all source search paths}
\DoxyCodeLine{    -\/ +:project/source/**            \#all subdirectories recursively discovered plus parent directory}
\DoxyCodeLine{    -\/ -\/:project/source/os/generated  \#subtract os/generated directory from expansion of above glob}
\DoxyCodeLine{                                     \#note that '+:' notation is merely aesthetic; default is to add}
\DoxyCodeLine{}
\DoxyCodeLine{  :test:                             \#all test search paths}
\DoxyCodeLine{    -\/ project/test/bootloader        \#explicit, single search paths (searched in the order specified)}
\DoxyCodeLine{    -\/ project/test/application}
\DoxyCodeLine{    -\/ project/test/utilities}
\DoxyCodeLine{}
\DoxyCodeLine{  :custom:                           \#custom path list}
\DoxyCodeLine{    -\/ "{}\#\{PROJECT\_ROOT\}/other"{}        \#inline Ruby string expansion}

\end{DoxyCode}


Globs and inline Ruby string expansion can require trial and error to arrive at your intended results. Use the {\ttfamily ceedling paths\+:$\ast$} command line options (documented in preceding section) to verify your settings.

Ceedling relies on file collections automagically assembled from paths, globs, and file extensions. File collections greatly simplify project set up. However, sometimes you need to remove from or add individual files to those collections.


\begin{DoxyItemize}
\item {\ttfamily test}\+:

Modify the collection of unit test C files.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily source}\+:

Modify the collection of all source files used in unit test builds and release builds.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily assembly}\+:

Modify the (optional) collection of assembly files used in release builds.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily include}\+:

Modify the collection of all source header files used in unit test builds (e.\+g. for mocking) and release builds.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily support}\+:

Modify the collection of supporting C files available to unit tests builds.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

Note\+: All path grammar documented in \mbox{[}\+:paths\mbox{]} section applies to \mbox{[}\+:files\mbox{]} path entries -\/ albeit at the file path level and not the directory level.

Example \mbox{[}\+:files\mbox{]} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:files:}
\DoxyCodeLine{  :source:}
\DoxyCodeLine{    -\/ callbacks/comm.c        \# entry defaults to file addition}
\DoxyCodeLine{    -\/ +:callbacks/comm*.c     \# add all comm files matching glob pattern}
\DoxyCodeLine{    -\/ -\/:source/board/atm134.c \# not our board}
\DoxyCodeLine{  :test:}
\DoxyCodeLine{    -\/ -\/:test/io/test\_output\_manager.c \# remove unit tests from test build}

\end{DoxyCode}


{\bfseries{environment\+:}} inserts environment variables into the shell instance executing configured tools

Ceedling creates environment variables from any key / value pairs in the environment section. Keys become an environment variable name in uppercase. The values are strings assigned to those environment variables. These value strings are either simple string values in YAML or the concatenation of a YAML array.

Ceedling is able to execute inline Ruby string substitution code to set environment variables. This evaluation occurs when the project file is first processed for any environment pair\textquotesingle{}s value string including the Ruby string substitution pattern {\ttfamily \#\{…\}}. Note that environment value strings that {\itshape begin} with this pattern should always be enclosed in quotes. YAML defaults to processing unquoted text as a string; quoting text is optional. If an environment pair\textquotesingle{}s value string begins with the Ruby string substitution pattern, YAML will interpret the string as a Ruby comment (because of the {\ttfamily \#}). Enclosing each environment value string in quotes is a safe practice.

\mbox{[}\+:environment\mbox{]} entries are processed in the configured order (later entries can reference earlier entries).

Special case\+: PATH handling

In the specific case of specifying an environment key named {\itshape path}, an array of string values will be concatenated with the appropriate platform-\/specific path separation character (e.\+g. \textquotesingle{}\+:\textquotesingle{} on $\ast$nix, \textquotesingle{};\textquotesingle{} on Windows). All other instances of environment keys assigned YAML arrays use simple concatenation.

Example \mbox{[}\+:environment\mbox{]} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:environment:}
\DoxyCodeLine{  -\/ :license\_server: gizmo.intranet        \#LICENSE\_SERVER set with value "{}gizmo.intranet"{}}
\DoxyCodeLine{  -\/ :license: "{}\#\{`license.exe`\}"{}           \#LICENSE set to string generated from shelling out to}
\DoxyCodeLine{                                           \#execute license.exe; note use of enclosing quotes}
\DoxyCodeLine{}
\DoxyCodeLine{  -\/ :path:                                 \#concatenated with path separator (see special case above)}
\DoxyCodeLine{     -\/ Tools/gizmo/bin                     \#prepend existing PATH with gizmo path}
\DoxyCodeLine{     -\/ "{}\#\{ENV['PATH']\}"{}                    \#pattern \#\{…\} triggers ruby evaluation string substitution}
\DoxyCodeLine{                                           \#note: value string must be quoted because of '\#'}
\DoxyCodeLine{}
\DoxyCodeLine{  -\/ :logfile: system/logs/thingamabob.log  \#LOGFILE set with path for a log file}

\end{DoxyCode}


{\bfseries{extension}}\+: configure file name extensions used to collect lists of files searched in \mbox{[}\+:paths\mbox{]}


\begin{DoxyItemize}
\item {\ttfamily header}\+:

C header files

{\bfseries{Default}}\+: .h
\item {\ttfamily source}\+:

C code files (whether source or test files)

{\bfseries{Default}}\+: .c
\item {\ttfamily assembly}\+:

Assembly files (contents wholly assembly instructions)

{\bfseries{Default}}\+: .s
\item {\ttfamily object}\+:

Resulting binary output of C code compiler (and assembler)

{\bfseries{Default}}\+: .o
\item {\ttfamily executable}\+:

Binary executable to be loaded and executed upon target hardware

{\bfseries{Default}}\+: .exe or .out (Win or $\ast$nix)
\item {\ttfamily testpass}\+:

Test results file (not likely to ever need a new value)

{\bfseries{Default}}\+: .pass
\item {\ttfamily testfail}\+:

Test results file (not likely to ever need a new value)

{\bfseries{Default}}\+: .fail
\item {\ttfamily dependencies}\+:

File containing make-\/style dependency rules created by gcc preprocessor

{\bfseries{Default}}\+: .d
\end{DoxyItemize}

Example \mbox{[}\+:extension\mbox{]} YAML blurb \begin{DoxyVerb}:extension:
  :source: .cc
  :executable: .bin
\end{DoxyVerb}
 {\bfseries{defines}}\+: command line defines used in test and release compilation by configured tools


\begin{DoxyItemize}
\item {\ttfamily test}\+:

Defines needed for testing. Useful for\+:
\begin{DoxyEnumerate}
\item test files containing conditional compilation statements (i.\+e. tests active in only certain contexts)
\item testing legacy source wherein the isolation of source under test afforded by Ceedling and its complementary tools leaves certain symbols unset when source files are compiled in isolation
\end{DoxyEnumerate}

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily test\+\_\+preprocess}\+:

If \mbox{[}\+:project\mbox{]}\mbox{[}\+:use\+\_\+test\+\_\+preprocessor\mbox{]} or \mbox{[}\+:project\mbox{]}\mbox{[}\+:use\+\_\+deep\+\_\+dependencies\mbox{]} is set and code is structured in a certain way, the gcc preprocessor may need symbol definitions to properly preprocess files to extract function signatures for mocking and extract deep dependencies for incremental builds.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily release}\+:

Defines needed for the release build binary artifact.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily release\+\_\+preprocess}\+:

If \mbox{[}\+:project\mbox{]}\mbox{[}\+:use\+\_\+deep\+\_\+dependencies\mbox{]} is set and code is structured in a certain way, the gcc preprocessor may need symbol definitions to properly preprocess files for incremental release builds due to deep dependencies.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

Example \mbox{[}\+:defines\mbox{]} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:defines:}
\DoxyCodeLine{  :test:}
\DoxyCodeLine{    -\/ UNIT\_TESTING  \#for select cases in source to allow testing with a changed behavior or interface}
\DoxyCodeLine{    -\/ OFF=0}
\DoxyCodeLine{    -\/ ON=1}
\DoxyCodeLine{    -\/ FEATURE\_X=ON}
\DoxyCodeLine{  :source:}
\DoxyCodeLine{    -\/ FEATURE\_X=ON}

\end{DoxyCode}


{\bfseries{libraries}}\+: command line defines used in test and release compilation by configured tools

Ceedling allows you to pull in specific libraries for the purpose of release and test builds. It has a few levels of support for this. Start by adding a \+:libraries main section in your configuration. In this section, you can optionally have the following subsections\+:


\begin{DoxyItemize}
\item {\ttfamily test}\+:

Library files that should be injected into your tests when linking occurs. These can be specified as either relative or absolute paths. These files MUST exist when the test attempts to build.
\item {\ttfamily source}\+:

Library files that should be injected into your release when linking occurs. These can be specified as either relative or absolute paths. These files MUST exist when the release attempts to build UNLESS you are using the subprojects plugin. In that case, it will attempt to build that library for you as a dynamic dependency.
\item {\ttfamily system}\+:

These libraries are assumed to be in the tool path somewhere and shouldn\textquotesingle{}t need to be specified. The libraries added here will be injected into releases and tests.
\item {\ttfamily flag}\+:

This is the method of adding an argument for each library. For example, gcc really likes it when you specify “-\/l\$\{1\}”
\end{DoxyItemize}

Notes\+:


\begin{DoxyItemize}
\item If you\textquotesingle{}ve specified your own link step, you are going to want to add \$\{4\} to your argument list in the place where library files should be added to the command call. For gcc, this is often the very end. Other tools may vary.
\end{DoxyItemize}

{\bfseries{flags}}\+: configure per-\/file compilation and linking flags

Ceedling tools (see later \mbox{[}\+:tools\mbox{]} section) are used to configure compilation and linking of test and source files. These tool configurations are a one-\/size-\/fits-\/all approach. Should individual files require special compilation or linking flags, the settings in the \mbox{[}\+:flags\mbox{]} section work in conjunction with tool definitions by way of argument substitution to achieve this.


\begin{DoxyItemize}
\item {\ttfamily release}\+:

\mbox{[}\+:compile\mbox{]} or \mbox{[}\+:link\mbox{]} flags for release build
\item {\ttfamily test}\+:

\mbox{[}\+:compile\mbox{]} or \mbox{[}\+:link\mbox{]} flags for test build
\end{DoxyItemize}

Notes\+:


\begin{DoxyItemize}
\item Ceedling works with the \mbox{[}\+:release\mbox{]} and \mbox{[}\+:test\mbox{]} build contexts as-\/is; plugins can add additional contexts
\item Only \mbox{[}\+:compile\mbox{]} and \mbox{[}\+:link\mbox{]} are recognized operations beneath a context
\item File specifiers do not include a path or file extension
\item File specifiers are case sensitive (must match original file name)
\item File specifiers do support regular expressions if encased in quotes
\item \textquotesingle{}$\ast$\textquotesingle{} is a special (optional) file specifier to provide flags to all files not otherwise specified
\end{DoxyItemize}

Example \mbox{[}\+:flags\mbox{]} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:flags:}
\DoxyCodeLine{  :release:}
\DoxyCodeLine{    :compile:}
\DoxyCodeLine{      :main:       \# add '-\/Wall' to compilation of main.c}
\DoxyCodeLine{        -\/ -\/Wall}
\DoxyCodeLine{      :fan:        \# add '-\/-\/O2' to compilation of fan.c}
\DoxyCodeLine{        -\/ -\/-\/O2}
\DoxyCodeLine{      :'test\_.+':   \# add '-\/pedantic' to all test-\/files}
\DoxyCodeLine{        -\/ -\/pedantic}
\DoxyCodeLine{      :*:          \# add '-\/foo' to compilation of all files not main.c or fan.c}
\DoxyCodeLine{        -\/ -\/foo}
\DoxyCodeLine{  :test:}
\DoxyCodeLine{    :compile:}
\DoxyCodeLine{      :main:       \# add '-\/-\/O1' to compilation of main.c as part of test builds including main.c}
\DoxyCodeLine{        -\/ -\/-\/O1}
\DoxyCodeLine{    :link:}
\DoxyCodeLine{      :test\_main:  \# add '-\/-\/bar -\/-\/baz' to linking of test\_main.exe}
\DoxyCodeLine{        -\/ -\/-\/bar}
\DoxyCodeLine{        -\/ -\/-\/baz}

\end{DoxyCode}


Ceedling sets values for a subset of CMock settings. All CMock options are available to be set, but only those options set by Ceedling in an automated fashion are documented below. See CMock documentation.

{\bfseries{cmock}}\+: configure CMock\textquotesingle{}s code generation options and set symbols used to modify CMock\textquotesingle{}s compiled features Ceedling sets values for a subset of CMock settings. All CMock options are available to be set, but only those options set by Ceedling in an automated fashion are documented below. See CMock documentation.


\begin{DoxyItemize}
\item {\ttfamily enforce\+\_\+strict\+\_\+ordering}\+:

Tests fail if expected call order is not same as source order

{\bfseries{Default}}\+: TRUE
\item {\ttfamily mock\+\_\+path}\+:

Path for generated mocks

{\bfseries{Default}}\+: $<$build path$>$/tests/mocks
\item {\ttfamily defines}\+:

List of conditional compilation symbols used to configure CMock\textquotesingle{}s compiled features. See CMock documentation to understand available options. No symbols must be set unless defaults are inappropriate for your specific environment. All symbols are used only by Ceedling to compile CMock C code; contents of \mbox{[}\+:defines\mbox{]} are ignored by CMock\textquotesingle{}s Ruby code when instantiated.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily verbosity}\+:

If not set, defaults to Ceedling\textquotesingle{}s verbosity level
\item {\ttfamily plugins}\+:

If \mbox{[}\+:project\mbox{]}\mbox{[}\+:use\+\_\+exceptions\mbox{]} is enabled, the internal plugins list is pre-\/populated with \textquotesingle{}cexception\textquotesingle{}.

Whether or not you have included \mbox{[}\+:cmock\mbox{]}\mbox{[}\+:plugins\mbox{]} in your configuration file, Ceedling automatically adds \textquotesingle{}cexception\textquotesingle{} to the plugin list if exceptions are enabled. To add to the list Ceedling provides CMock, simply add \mbox{[}\+:cmock\mbox{]}\mbox{[}\+:plugins\mbox{]} to your configuration and specify your desired additional plugins.
\item {\ttfamily includes}\+:

If \mbox{[}\+:cmock\mbox{]}\mbox{[}\+:unity\+\_\+helper\mbox{]} set, pre-\/populated with unity\+\_\+helper file name (no path).

The \mbox{[}\+:cmock\mbox{]}\mbox{[}\+:includes\mbox{]} list works identically to the plugins list above with regard to adding additional files to be inserted within mocks as \#include statements.
\end{DoxyItemize}

The last four settings above are directly tied to other Ceedling settings; hence, why they are listed and explained here. The first setting above, \mbox{[}\+:enforce\+\_\+strict\+\_\+ordering\mbox{]}, defaults to FALSE within CMock. It is set to TRUE by default in Ceedling as our way of encouraging you to use strict ordering. It\textquotesingle{}s a teeny bit more expensive in terms of code generated, test execution time, and complication in deciphering test failures. However, it\textquotesingle{}s good practice. And, of course, you can always disable it by overriding the value in the Ceedling YAML configuration file.

{\bfseries{cexception}}\+: configure symbols used to modify CException\textquotesingle{}s compiled features


\begin{DoxyItemize}
\item {\ttfamily defines}\+:

List of conditional compilation symbols used to configure CException\textquotesingle{}s features in its source and header files. See CException documentation to understand available options. No symbols must be set unless the defaults are inappropriate for your specific environment.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

{\bfseries{unity}}\+: configure symbols used to modify Unity\textquotesingle{}s compiled features


\begin{DoxyItemize}
\item {\ttfamily defines}\+:

List of conditional compilation symbols used to configure Unity\textquotesingle{}s features in its source and header files. See Unity documentation to understand available options. No symbols must be set unless the defaults are inappropriate for your specific environment. Most Unity defines can be easily configured through the YAML file.

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

Example \mbox{[}\+:unity\mbox{]} YAML blurbs 
\begin{DoxyCode}{0}
\DoxyCodeLine{:unity: \#itty bitty processor \& toolchain with limited test execution options}
\DoxyCodeLine{  :defines:}
\DoxyCodeLine{    -\/ UNITY\_INT\_WIDTH=16           \#16 bit processor without support for 32 bit instructions}
\DoxyCodeLine{    -\/ UNITY\_EXCLUDE\_FLOAT          \#no floating point unit}
\DoxyCodeLine{}
\DoxyCodeLine{:unity: \#great big gorilla processor that grunts and scratches}
\DoxyCodeLine{  :defines:}
\DoxyCodeLine{    -\/ UNITY\_SUPPORT\_64                    \#big memory, big counters, big registers}
\DoxyCodeLine{    -\/ UNITY\_LINE\_TYPE=\(\backslash\)"{}unsigned int\(\backslash\)"{}    \#apparently we're using really long test files,}
\DoxyCodeLine{    -\/ UNITY\_COUNTER\_TYPE=\(\backslash\)"{}unsigned int\(\backslash\)"{} \#and we've got a ton of test cases in those test files}
\DoxyCodeLine{    -\/ UNITY\_FLOAT\_TYPE=\(\backslash\)"{}double\(\backslash\)"{}         \#you betcha}

\end{DoxyCode}


Notes on Unity configuration\+:


\begin{DoxyItemize}
\item {\bfseries{Verification}} -\/ Ceedling does no verification of your configuration values. In a properly configured setup, your Unity configuration values are processed, collected together with any test define symbols you specify elsewhere, and then passed to your toolchain during test compilation. Unity\textquotesingle{}s conditional compilation statements, your toolchain\textquotesingle{}s preprocessor, and/or your toolchain\textquotesingle{}s compiler will complain appropriately if your specified configuration values are incorrect, incomplete, or incompatible.
\item {\bfseries{Routing \$stdout}} -\/ Unity defaults to using {\ttfamily putchar()} in C\textquotesingle{}s standard library to display test results. For more exotic environments than a desktop with a terminal (e.\+g. running tests directly on a non-\/\+PC target), you have options. For example, you could create a routine that transmits a character via RS232 or USB. Once you have that routine, you can replace {\ttfamily putchar()} calls in Unity by overriding the function-\/like macro {\ttfamily UNITY\+\_\+\+OUTPUT\+\_\+\+CHAR}. Consult your toolchain and shell documentation. Eventhough this can also be defined in the YAML file most shell environments do not handle parentheses as command line arguments very well. To still be able to add this functionality all necessary options can be defined in the {\ttfamily unity\+\_\+config.\+h}. Unity needs to be told to look for the {\ttfamily unity\+\_\+config.\+h} in the YAML file, though.
\end{DoxyItemize}

Example \mbox{[}\+:unity\mbox{]} YAML blurbs 
\begin{DoxyCode}{0}
\DoxyCodeLine{:unity:}
\DoxyCodeLine{  :defines:}
\DoxyCodeLine{    -\/ UNITY\_INCLUDE\_CONFIG\_H}

\end{DoxyCode}


Example unity\+\_\+config.\+h 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#ifndef UNITY\_CONFIG\_H}
\DoxyCodeLine{\#define UNITY\_CONFIG\_H}
\DoxyCodeLine{}
\DoxyCodeLine{\#include "{}uart\_output.h"{} //Helper library for your custom environment}
\DoxyCodeLine{}
\DoxyCodeLine{\#define UNITY\_INT\_WIDTH 16}
\DoxyCodeLine{\#define UNITY\_OUTPUT\_START() uart\_init(F\_CPU, BAUD) //Helperfunction to init UART}
\DoxyCodeLine{\#define UNITY\_OUTPUT\_CHAR(a) uart\_putchar(a) //Helperfunction to forward char via UART}
\DoxyCodeLine{\#define UNITY\_OUTPUT\_COMPLETE() uart\_complete() //Helperfunction to inform that test has ended}
\DoxyCodeLine{}
\DoxyCodeLine{\#endif}

\end{DoxyCode}


{\bfseries{tools}}\+: a means for representing command line tools for use under Ceedling\textquotesingle{}s automation framework

Ceedling requires a variety of tools to work its magic. By default, the GNU toolchain (gcc, cpp, as) are configured and ready for use with no additions to the project configuration YAML file. However, as most work will require a project-\/specific toolchain, Ceedling provides a generic means for specifying / overriding tools.


\begin{DoxyItemize}
\item {\ttfamily test\+\_\+compiler}\+:

Compiler for test \& source-\/under-\/test code \$\{1\}\+: input source \$\{2\}\+: output object \$\{3\}\+: optional output list \$\{4\}\+: optional output dependencies file

{\bfseries{Default}}\+: gcc
\item {\ttfamily test\+\_\+linker}\+:

Linker to generate test fixture executables \$\{1\}\+: input objects \$\{2\}\+: output binary \$\{3\}\+: optional output map \$\{4\}\+: optional library list

{\bfseries{Default}}\+: gcc
\item {\ttfamily test\+\_\+fixture}\+:

Executable test fixture \$\{1\}\+: simulator as executable with \$\{1\} as input binary file argument or native test executable

{\bfseries{Default}}\+: \$\{1\}
\item {\ttfamily test\+\_\+includes\+\_\+preprocessor}\+:

Extractor of \#include statements \$\{1\}\+: input source file

{\bfseries{Default}}\+: cpp
\item {\ttfamily test\+\_\+file\+\_\+preprocessor}\+:

Preprocessor of test files (macros, conditional compilation statements) \$\{1\}\+: input source file \$\{2\}\+: preprocessed output source file

{\bfseries{Default}}\+: gcc
\item {\ttfamily test\+\_\+dependencies\+\_\+generator}\+:

Discovers deep dependencies of source \& test (for incremental builds) \$\{1\}\+: input source file \$\{2\}\+: compiled object filepath \$\{3\}\+: output dependencies file

{\bfseries{Default}}\+: gcc
\item {\ttfamily release\+\_\+compiler}\+:

Compiler for release source code \$\{1\}\+: input source \$\{2\}\+: output object \$\{3\}\+: optional output list \$\{4\}\+: optional output dependencies file

{\bfseries{Default}}\+: gcc
\item {\ttfamily release\+\_\+assembler}\+:

Assembler for release assembly code \$\{1\}\+: input assembly source file \$\{2\}\+: output object file

{\bfseries{Default}}\+: as
\item {\ttfamily release\+\_\+linker}\+:

Linker for release source code \$\{1\}\+: input objects \$\{2\}\+: output binary \$\{3\}\+: optional output map \$\{4\}\+: optional library list

{\bfseries{Default}}\+: gcc
\item {\ttfamily release\+\_\+dependencies\+\_\+generator}\+:

Discovers deep dependencies of source files (for incremental builds) \$\{1\}\+: input source file \$\{2\}\+: compiled object filepath \$\{3\}\+: output dependencies file

{\bfseries{Default}}\+: gcc
\end{DoxyItemize}

A Ceedling tool has a handful of configurable elements\+:


\begin{DoxyEnumerate}
\item \mbox{[}\+:executable\mbox{]} (required) -\/ Command line executable having the form of\+:
\item \mbox{[}\+:arguments\mbox{]} (required) -\/ List of command line arguments and substitutions
\item \mbox{[}\+:name\mbox{]} -\/ Simple name (e.\+g. \char`\"{}nickname\char`\"{}) of tool beyond its executable name (if not explicitly set then Ceedling will form a name from the tool\textquotesingle{}s YAML entry name)
\item \mbox{[}\+:stderr\+\_\+redirect\mbox{]} -\/ Control of capturing \$stderr messages \{\+:none, \+:auto, \+:win, \+:unix, \+:tcsh\}. Defaults to \+:none if unspecified; create a custom entry by specifying a simple string instead of any of the available symbols.
\item \mbox{[}\+:background\+\_\+exec\mbox{]} -\/ Control execution as background process \{\+:none, \+:auto, \+:win, \+:unix\}. Defaults to \+:none if unspecified.
\end{DoxyEnumerate}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md11}{}\doxysubsection{Tool Element Runtime Substitution}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md11}
To accomplish useful work on multiple files, a configured tool will most often require that some number of its arguments or even the executable itself change for each run. Consequently, every tool\textquotesingle{}s argument list and executable field possess two means for substitution at runtime. Ceedling provides two kinds of inline Ruby execution and a notation for populating elements with dynamically gathered values within the build environment.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md12}{}\doxysubsection{Tool Element Runtime Substitution\+: Inline Ruby Execution}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md12}
In-\/line Ruby execution works similarly to that demonstrated for the \mbox{[}\+:environment\mbox{]} section except that substitution occurs as the tool is executed and not at the time the configuration file is first scanned.


\begin{DoxyItemize}
\item {\ttfamily \#\{...\}}\+:

Ruby string substitution pattern wherein the containing string is expanded to include the string generated by Ruby code between the braces. Multiple instances of this expansion can occur within a single tool element entry string. Note that if this string substitution pattern occurs at the very beginning of a string in the YAML configuration the entire string should be enclosed in quotes (see the \mbox{[}\+:environment\mbox{]} section for further explanation on this point).
\item {\ttfamily \{...\}}\+:

If an entire tool element string is enclosed with braces, it signifies that Ceedling should execute the Ruby code contained within those braces. Say you have a collection of paths on disk and some of those paths include spaces. Further suppose that a single tool that must use those paths requires those spaces to be escaped, but all other uses of those paths requires the paths to remain unchanged. You could use this Ceedling feature to insert Ruby code that iterates those paths and escapes those spaces in the array as used by the tool of this example.
\end{DoxyItemize}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md13}{}\doxysubsection{Tool Element Runtime Substitution\+: Notational Substitution}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md13}
A Ceedling tool\textquotesingle{}s other form of dynamic substitution relies on a \textquotesingle{}\$\textquotesingle{} notation. These \textquotesingle{}\$\textquotesingle{} operators can exist anywhere in a string and can be decorated in any way needed. To use a literal \textquotesingle{}\$\textquotesingle{}, escape it as \textquotesingle{}\textbackslash{}\$\textquotesingle{}.


\begin{DoxyItemize}
\item {\ttfamily \$}\+:

Simple substitution for value(s) globally available within the runtime (most often a string or an array).
\item {\ttfamily \$\{\#\}}\+:

When a Ceedling tool\textquotesingle{}s command line is expanded from its configured representation and used within Ceedling Ruby code, certain calls to that tool will be made with a parameter list of substitution values. Each numbered substitution corresponds to a position in a parameter list. Ceedling Ruby code expects that configured compiler and linker tools will contain \$\{1\} and \$\{2\} replacement arguments. In the case of a compiler \$\{1\} will be a C code file path, and \$\{2\} will be the file path of the resulting object file. For a linker \$\{1\} will be an array of object files to link, and \$\{2\} will be the resulting binary executable. For an executable test fixture \$\{1\} is either the binary executable itself (when using a local toolchain such as gcc) or a binary input file given to a simulator in its arguments.
\end{DoxyItemize}

Example \mbox{[}\+:tools\mbox{]} YAML blurbs


\begin{DoxyCode}{0}
\DoxyCodeLine{:tools:}
\DoxyCodeLine{  :test\_compiler:}
\DoxyCodeLine{     :executable: compiler              \#exists in system search path}
\DoxyCodeLine{     :name: 'acme test compiler'}
\DoxyCodeLine{     :arguments:}
\DoxyCodeLine{        -\/ -\/I"{}\$"{}: COLLECTION\_PATHS\_TEST\_TOOLCHAIN\_INCLUDE               \#expands to -\/I search paths}
\DoxyCodeLine{        -\/ -\/I"{}\$"{}: COLLECTION\_PATHS\_TEST\_SUPPORT\_SOURCE\_INCLUDE\_VENDOR   \#expands to -\/I search paths}
\DoxyCodeLine{        -\/ -\/D\$: COLLECTION\_DEFINES\_TEST\_AND\_VENDOR  \#expands to all -\/D defined symbols}
\DoxyCodeLine{        -\/ -\/-\/network-\/license             \#simple command line argument}
\DoxyCodeLine{        -\/ -\/optimize-\/level 4             \#simple command line argument}
\DoxyCodeLine{        -\/ "{}\#\{`args.exe -\/m acme.prj`\}"{}   \#in-\/line ruby sub to shell out \& build string of arguments}
\DoxyCodeLine{        -\/ -\/c \$\{1\}                       \#source code input file (Ruby method call param list sub)}
\DoxyCodeLine{        -\/ -\/o \$\{2\}                       \#object file output (Ruby method call param list sub)}
\DoxyCodeLine{  :test\_linker:}
\DoxyCodeLine{     :executable: /programs/acme/bin/linker.exe    \#absolute file path}
\DoxyCodeLine{     :name: 'acme test linker'}
\DoxyCodeLine{     :arguments:}
\DoxyCodeLine{        -\/ \$\{1\}               \#list of object files to link (Ruby method call param list sub)}
\DoxyCodeLine{        -\/ -\/l\$-\/lib:           \#inline yaml array substitution to link in foo-\/lib and bar-\/lib}
\DoxyCodeLine{           -\/ foo}
\DoxyCodeLine{           -\/ bar}
\DoxyCodeLine{        -\/ -\/o \$\{2\}            \#executable file output (Ruby method call param list sub)}
\DoxyCodeLine{  :test\_fixture:}
\DoxyCodeLine{     :executable: tools/bin/acme\_simulator.exe  \#relative file path to command line simulator}
\DoxyCodeLine{     :name: 'acme test fixture'}
\DoxyCodeLine{     :stderr\_redirect: :win                     \#inform Ceedling what model of \$stderr capture to use}
\DoxyCodeLine{     :arguments:}
\DoxyCodeLine{        -\/ -\/mem large   \#simple command line argument}
\DoxyCodeLine{        -\/ -\/f "{}\$\{1\}"{}    \#binary executable input file to simulator (Ruby method call param list sub)}

\end{DoxyCode}


Resulting command line constructions from preceding example \mbox{[}\+:tools\mbox{]} YAML blurbs \begin{DoxyVerb}> compiler -I"/usr/include” -I”project/tests”
  -I"project/tests/support” -I”project/source” -I”project/include”
  -DTEST -DLONG_NAMES -network-license -optimize-level 4 arg-foo
  arg-bar arg-baz -c project/source/source.c -o
  build/tests/out/source.o
\end{DoxyVerb}
 \mbox{[}notes\+: (1.) \char`\"{}arg-\/foo arg-\/bar arg-\/baz\char`\"{} is a fabricated example string collected from \$stdout as a result of shell execution of args.\+exe (2.) the -\/c and -\/o arguments are fabricated examples simulating a single compilation step for a test; \$\{1\} \& \$\{2\} are single files\mbox{]} \begin{DoxyVerb}> \programs\acme\bin\linker.exe thing.o unity.o
  test_thing_runner.o test_thing.o mock_foo.o mock_bar.o -lfoo-lib
  -lbar-lib -o build\tests\out\test_thing.exe
\end{DoxyVerb}
 \mbox{[}note\+: in this scenario \$\{1\} is an array of all the object files needed to link a test fixture executable\mbox{]} \begin{DoxyVerb}> tools\bin\acme_simulator.exe -mem large -f "build\tests\out\test_thing.bin 2>&1”
\end{DoxyVerb}
 \mbox{[}note\+: (1.) \+:executable could have simply been \$\{1\} -\/ if we were compiling and running native executables instead of cross compiling (2.) we\textquotesingle{}re using \$stderr redirection to allow us to capture simulator error messages to \$stdout for display at the run\textquotesingle{}s conclusion\mbox{]}

Notes\+:


\begin{DoxyItemize}
\item The upper case names are Ruby global constants that Ceedling builds
\item \char`\"{}\+COLLECTION\+\_\+\char`\"{} indicates that Ceedling did some work to assemble the list. For instance, expanding path globs, combining multiple path globs into a convenient summation, etc.
\item At present, \$stderr redirection is primarily used to capture errors from test fixtures so that they can be displayed at the conclusion of a test run. For instance, if a simulator detects a memory access violation or a divide by zero error, this notice might go unseen in all the output scrolling past in a terminal.
\item The preprocessing tools can each be overridden with non-\/gcc equivalents. However, this is an advanced feature not yet documented and requires that the replacement toolchain conform to the same conventions used by gcc.
\end{DoxyItemize}

{\bfseries{Ceedling Collection Used in Compilation}}\+:


\begin{DoxyItemize}
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+TEST}\+:

All test paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+SOURCE}\+:

All source paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+INCLUDE}\+:

All include paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+SUPPORT}\+:

All test support paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+SOURCE\+\_\+\+AND\+\_\+\+INCLUDE}\+:

All source and include paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+SOURCE\+\_\+\+INCLUDE\+\_\+\+VENDOR}\+:

All source and include paths + applicable vendor paths (e.\+g. CException\textquotesingle{}s source path if exceptions enabled)
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+TEST\+\_\+\+TOOLCHAIN\+\_\+\+INCLUDE}\+:

All test toolchain include paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+TEST\+\_\+\+SUPPORT\+\_\+\+SOURCE\+\_\+\+INCLUDE}\+:

All test, source, and include paths
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+TEST\+\_\+\+SUPPORT\+\_\+\+SOURCE\+\_\+\+INCLUDE\+\_\+\+VENDOR}\+:

All test, source, include, and applicable vendor paths (e.\+g. Unity\textquotesingle{}s source path plus CMock and CException\textquotesingle{}s source paths if mocks and exceptions are enabled)
\item {\ttfamily COLLECTION\+\_\+\+PATHS\+\_\+\+RELEASE\+\_\+\+TOOLCHAIN\+\_\+\+INCLUDE}\+:

All release toolchain include paths
\item {\ttfamily COLLECTION\+\_\+\+DEFINES\+\_\+\+TEST\+\_\+\+AND\+\_\+\+VENDOR}\+:

All symbols specified in \mbox{[}\+:defines\mbox{]}\mbox{[}\+:test\mbox{]} + symbols defined for enabled vendor tools -\/ e.\+g. \mbox{[}\+:unity\mbox{]}\mbox{[}\+:defines\mbox{]}, \mbox{[}\+:cmock\mbox{]}\mbox{[}\+:defines\mbox{]}, and \mbox{[}\+:cexception\mbox{]}\mbox{[}\+:defines\mbox{]}
\item {\ttfamily COLLECTION\+\_\+\+DEFINES\+\_\+\+RELEASE\+\_\+\+AND\+\_\+\+VENDOR}\+:

All symbols specified in \mbox{[}\+:defines\mbox{]}\mbox{[}\+:release\mbox{]} plus symbols defined by \mbox{[}\+:cexception\mbox{]}\mbox{[}\+:defines\mbox{]} if exceptions are ena bled
\end{DoxyItemize}

Notes\+:


\begin{DoxyItemize}
\item Other collections exist within Ceedling. However, they are only useful for advanced features not yet documented.
\item Wherever multiple path lists are combined for use Ceedling prioritizes path groups as follows\+: test paths, support paths, source paths, include paths. This can be useful, for instance, in certain testing scenarios where we desire Ceedling or the compiler to find a stand-\/in header file before the actual source header file of the same name.
\end{DoxyItemize}

{\bfseries{plugins}}\+: Ceedling extensions


\begin{DoxyItemize}
\item {\ttfamily load\+\_\+paths}\+:

Base paths to search for plugin subdirectories or extra ruby functionalit

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\item {\ttfamily enabled}\+:

List of plugins to be used -\/ a plugin\textquotesingle{}s name is identical to the subdirectory that contains it (and the name of certain files within that subdirectory)

{\bfseries{Default}}\+: \mbox{[}\mbox{]} (empty)
\end{DoxyItemize}

Plugins can provide a variety of added functionality to Ceedling. In general use, it\textquotesingle{}s assumed that at least one reporting plugin will be used to format test results. However, if no reporting plugins are specified, Ceedling will print to {\ttfamily \$stdout} the (quite readable) raw test results from all test fixtures executed.

Example \mbox{[}\+:plugins\mbox{]} YAML blurb


\begin{DoxyCode}{0}
\DoxyCodeLine{:plugins:}
\DoxyCodeLine{  :load\_paths:}
\DoxyCodeLine{    -\/ project/tools/ceedling/plugins  \#home to your collection of plugin directories}
\DoxyCodeLine{    -\/ project/support                 \#maybe home to some ruby code your custom plugins share}
\DoxyCodeLine{  :enabled:}
\DoxyCodeLine{    -\/ stdout\_pretty\_tests\_report      \#nice test results at your command line}
\DoxyCodeLine{    -\/ our\_custom\_code\_metrics\_report  \#maybe you needed line count and complexity metrics, so you}
\DoxyCodeLine{                                      \#created a plugin to scan all your code and collect that info}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily stdout\+\_\+pretty\+\_\+tests\+\_\+report}\+:

Prints to \$stdout a well-\/formatted list of ignored and failed tests, final test counts, and any extraneous output (e.\+g. printf statements or simulator memory errors) collected from executing the test fixtures. Meant to be used with runs at the command line.
\item {\ttfamily stdout\+\_\+ide\+\_\+tests\+\_\+report}\+:

Prints to \$stdout simple test results formatted such that an IDE executing test-\/related Rake tasks can recognize file paths and line numbers in test failures, etc. Thus, you can click a test result in your IDE\textquotesingle{}s execution window and jump to the failure (or ignored test) in your test file (obviously meant to be used with an \href{http://throwtheswitch.org/white-papers/using-with-ides.html}{\texttt{ IDE like Eclipse}}, etc).
\item {\ttfamily xml\+\_\+tests\+\_\+report}\+:

Creates an XML file of test results in the x\+Unit format (handy for Continuous Integration build servers or as input to other reporting tools). Produces a file report.\+xml in $<$build root$>$/artifacts/tests.
\item {\ttfamily bullseye}\+:

Adds additional Rake tasks to execute tests with the commercial code coverage tool provided by \href{http://www.bullseye.com}{\texttt{ Bullseye}}. See readme.\+txt inside the bullseye plugin directory for configuration and use instructions. Note\+: Bullseye only works with certain compilers and linkers (healthy list of supported toolchains though).
\item {\ttfamily gcov}\+:

Adds additional Rake tasks to execute tests with the GNU code coverage tool \href{http://gcc.gnu.org/onlinedocs/gcc/Gcov.html}{\texttt{ gcov}}. See readme.\+txt inside the gcov directory for configuration and use instructions. Only works with GNU compiler and linker.
\item {\ttfamily warnings\+\_\+report}\+:

Scans compiler and linker {\ttfamily \$stdout / \$stderr} output for the word \textquotesingle{}warning\textquotesingle{} (case insensitive). All code warnings (or tool warnings) are logged to a file warnings.\+log in the appropriate {\ttfamily $<$build root$>$/artifacts} directory (e.\+g. test/ for test tasks, {\ttfamily release/} for a release build, or even {\ttfamily bullseye/} for bullseye runs).
\end{DoxyItemize}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md14}{}\doxysection{Module Generator}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md14}
Ceedling includes a plugin called module\+\_\+generator that will create a source, header and test file for you. There are several possibilities to configure this plugin through your project.\+yml to suit your project\textquotesingle{}s needs.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md15}{}\doxysubsection{Directory Structure}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md15}
The default configuration for directory/project structure is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{:module\_generator:}
\DoxyCodeLine{  :project\_root: ./}
\DoxyCodeLine{  :source\_root: src/}
\DoxyCodeLine{  :test\_root: test/}

\end{DoxyCode}
 You can change these variables in your project.\+yml file to comply with your project\textquotesingle{}s directory structure.

If you call {\ttfamily ceedling module\+:create}, it will create three files\+:
\begin{DoxyEnumerate}
\item A source file in the source\+\_\+root
\item A header file in the source\+\_\+root
\item A test file in the test\+\_\+root
\end{DoxyEnumerate}

If you want your header file to be in another location, you can specify the \textquotesingle{}\+:inc\+\_\+root\+:"{} in your project.\+yml file\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{:module\_generator:}
\DoxyCodeLine{  :inc\_root: inc/}

\end{DoxyCode}
 The module\+\_\+generator will then create the header file in your defined \textquotesingle{}\+:inc\+\_\+root\+:\textquotesingle{}. By default, \textquotesingle{}\+:inc\+\_\+root\+:\textquotesingle{} is not defined so the module\+\_\+generator will use the source\+\_\+root.

Sometimes, your project can\textquotesingle{}t be divided into a single src, inc, and test folder. You have several directories with sources/..., something like this for example\+: $<$project\+\_\+root$>$
\begin{DoxyItemize}
\item my\+Driver
\begin{DoxyItemize}
\item src
\item inc
\item test
\end{DoxyItemize}
\item my\+Other\+Driver
\begin{DoxyItemize}
\item src
\item inc
\item test
\end{DoxyItemize}
\item ...
\end{DoxyItemize}

Don\textquotesingle{}t worry, you don\textquotesingle{}t have to manually create the source/header/test files. The module\+\_\+generator can accept a path to create a source\+\_\+root/inc\+\_\+root/test\+\_\+root folder with your files\+: {\ttfamily ceedling module\+:create\mbox{[}$<$module\+\_\+root\+\_\+path$>$\+:$<$module\+\_\+name$>$\mbox{]}}

F.\+e., applied to the above project structure\+: {\ttfamily ceedling module\+:create\mbox{[}my\+Other\+Driver\+:driver\mbox{]}} This will make the module\+\_\+generator run in the subdirectory \textquotesingle{}my\+Other\+Driver\textquotesingle{} and generate the module files for you in that directory. So, this command will generate the following files\+:
\begin{DoxyEnumerate}
\item A source file \textquotesingle{}driver.\+c\textquotesingle{} in $<$project\+\_\+root$>$/my\+Other\+Driver/$<$source\+\_\+root$>$
\item A header file \textquotesingle{}driver.\+h\textquotesingle{} in $<$project\+\_\+root$>$/my\+Other\+Driver/$<$source\+\_\+root$>$ (or $<$inc\+\_\+root$>$ if specified)
\item A test file \textquotesingle{}test\+\_\+driver.\+c\textquotesingle{} in $<$project\+\_\+root$>$/my\+Other\+Driver/$<$test\+\_\+root$>$
\end{DoxyEnumerate}\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md16}{}\doxysubsection{Naming}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md16}
By default, the module\+\_\+generator will generate your files in lowercase. {\ttfamily ceedling module\+:create\mbox{[}mydriver\mbox{]}} and {\ttfamily ceedling module\+:create\mbox{[}my\+Driver\mbox{]}}(note the uppercase) will generate the same files\+:
\begin{DoxyEnumerate}
\item mydriver.\+c
\item mydriver.\+h
\item test\+\_\+mydriver.\+c
\end{DoxyEnumerate}

You can configure the module\+\_\+generator to use a differect naming mechanism through the project.\+yml\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{:module\_generator:}
\DoxyCodeLine{  :naming: "{}camel"{}}

\end{DoxyCode}
 There are other possibilities as well (bumpy, camel, snake, caps). Refer to the unity module generator for more info (the unity module generator is used under the hood by module\+\_\+generator).\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md17}{}\doxysection{Advanced Topics (\+Coming)}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md17}
\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md18}{}\doxysubsection{Modifying Your Configuration without Modifying Your Project File\+: Option Files \& User Files}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md18}
Modifying your project file without modifying your project file\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md19}{}\doxysubsection{Debugging and/or printf()}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md19}
When you gotta get your hands dirty...\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md20}{}\doxysubsection{Ceedling Plays Nice with Others -\/ Using Ceedling for Tests Alongside Another Release Build Setup}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md20}
You\textquotesingle{}ve got options.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md21}{}\doxysubsection{Adding Handy Rake Tasks for Your Project (without Fancy Pants Custom Plugins)}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md21}
Simple as snot.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md22}{}\doxysubsection{Working with Non-\/\+Desktop Testing Environments}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md22}
For those crazy platforms lacking command line simulators and for which cross-\/compiling on the desktop just ain\textquotesingle{}t gonna get it done.\hypertarget{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md23}{}\doxysubsection{Creating Custom Plugins}\label{md__unit_test_framework_vendor_ceedling_docs__ceedling_packet_autotoc_md23}
Oh boy. This is going to take some explaining. 